\chapter{Historische Grundlage} %TODO Titel ändern? --> Grundlagen
\section{Implementierungsformen von Software}
Um Programme in einer bestimmten Programmiersprache für einen \ac{PC} lesbar zu machen müssen diese in Maschinencode, quasi die Muttersprache des \ac{PC}'s, übersetzt werden \cite[vgl. Wagenknecht Hielscher 2022, S.2ff]{wagenknecht_hielscher_2022}. Dazu gibt es verschiedene technische Implementierungsformen, die folgend kurz vorgestellt werden:

\subsection{Compiler}\label{ch_compiler}
Der Compiliervorgang ist ähnlich einem Übersetzungsvorgang von z.B. einem chinesischen Text in englische Sprache zu  sehen und kann gerade bei größeren Programmen durchaus Zeit in Anspruch nehmen und der Quellcode muss für jede Änderung erneut compiliert werden. Als Vorteil ist jedoch die schnelle Ausführung durch das Zielsystem zu nennen, da der Programmcode komplett in die korrespondierende Instruktionen dieses Zielsystems übersetzt wurde. \cite[vgl. Wagenknecht Hielscher, S.121]{wagenknecht_hielscher_2022}
Andererseits muss das Zielsystem bereits beim Compilationsvorgang bekannt sein und es kann nur allgemein für ein System, aber nicht zwangsläufig für die tatsächlich darunter liegende Hardware übersetzt werden. \\
Durch den Einsatz von höheren Programmiersprachen wurde der Einsatz von Compilern nötig, um den verfassten Quellcode für die jeweiligen Zielsysteme in den geeigneten Maschinencode zu übersetzen. Die für den Menschen einfacher zu verstehenden Programmiersprachen (auch Hochsprachen) bieten die Möglichkeit ihre Logik für verschiedene Zielsysteme durch einen Compiler zu übersetzen und somit sowohl dem Menschen, als auch dem \ac{PC} ein gut lesbares Format vorzuhalten, \cite[vgl. Wagenknecht Hielscher, S.1ff]{wagenknecht_hielscher_2022}.\\
Bereits Konrad Zuse setzte für seinen Zuse Z4 auf eine Art höhere Sprache, das sogenannte Plankalkül und wollte mit einem "Planfertigungsgerät" automatisch von einem mathematischen Rechenplan einen Lochstreifen mit gestanztem Maschinenplan anfertigen, \cite[vgl. Heilige 2013, S.45]{Hellige2013}. Nach heutiger Terminologie ist dieses Planfertigungsgerät bereits als Compiler zu betrachten. \\
Der erste Compiler A-0 wurde von Grace Hopper 1952 vorgestellt und erleichterte den Prozess der Programmierung hinlänglich, da statt direkter Maschinenbefehle nun Code aus verständlichen Algorithmen, die in einem Katalog zusammengefasst waren, aufgebaut werden konnten. Diese Bausteine wurden von A-0 aus dem Katalog abgerufen und der Code in korrekter Reihenfolge zusammen gesetzt. Benötigte Speicherbereiche wurden automatisch reserviert und die zugehörige Adressierung ebenfalls vom Compiler übernommen, \cite[vgl. Beyer 2012, S.222ff]{Beyer2012}. In der Weiterentwicklung, dem Prototypen B-0 konnten Befehle in verschiedenen menschlichen Sprachen (z.B. Englisch, Französisch, Deutsch) verwendet werden, die der Computer zu Maschinencode übersetzte, \cite[vg. Beyer 2012, S.271ff]{Beyer2012}.\\
Über Compiler für die Sprachen Fortran und COBOL wurden die Compiler schlussendlich soweit entwickelt, wie wir sie heute kennen. 

\subsection{Interpreter} \label{ch_interpreter}
Da die Klasse der Interpreter nicht konkret Teil dieser Arbeit, aber mit den Themen eng verwandt ist, soll hier kurz auf den Aufbau und die Geschichte eingegangen werden. \\
Ein Interpreter führt portionsweise Aktionen aus und interpretiert so zur Laufzeit den Quellcode zu maschinenlesbaren Instruktionen, wobei er im Unterschied zum Compiler keinen neuen Text erzeugt, sondern direkt den Quellcode zu Anweisungen übersetzt, \cite[vgl. Wagenknecht Hielscher 2022, S.4]{wagenknecht_hielscher_2022}. Interpreter werden oft von Skriptsprachen eingesetzt und ersparen den Compilationsvorgang im Vorfeld. \\
Außerdem können Interpretersprachen plattformunabhängig ausgeliefert werden, da die Interpretation erst auf dem Zielsystem ausgeführt wird und im Vorfeld nicht bekannt sein muss, auf welchem \ac{OS} der Quellcode ausgeführt werden soll. Das Zielsystem kann den Code somit für sich selbst interpretiere und die Instruktionen somit auch direkt für die eigene Hardware zielgerichtet umsetzen. \\
Andererseits entsteht durch die Interpretation zur Laufzeit ein erhöhter Aufwand, der Interpretersprachen grundsätzlich eine langsamere Ausführung beschert, als im Vorfeld zu Maschinencode kompilierten Programmen.\\
Interpreter entstanden ungefähr zur selben Zeit, wie die ersten Compiler und wurden erfunden, um zwischen verschiedenen Low-level-Sprache zu übersetzen und die allgemeine Programmierung zu vereinfachen, \cite[vgl. Bennet 1952, S.81 f]{Bennett1952}. \\
Der erste Interpreter wurde dabei von John Russel zusammen der Sprache LISP auf einem IBM 704 entwickelt, der dazu diente Lisp-Programme zu evaluieren, \cite[vgl. Stoyan S.299ff]{Stoyan1984}

\subsection{Just-in-time-Kompilierung} \label{ch_jit}
Die Implementierungsform der \ac{JIT}-Kompilierung versucht die Vorteile von \autoref{ch_interpreter} und \autoref{ch_compiler} zu vereinen. Einerseits wird der Code vorab zu Bytecode kompiliert, um eine schnellere Ausführung in einer virtuellen Maschine zu ermöglichen, andererseits wird der Code zur Laufzeit direkt auf der Zielmaschine von Bytecode in Maschinencode kompiliert, was den Vorteil bietet, dass dieser speziell für den ausführenden Prozessor optimiert werden kann.\\
\ac{JIT} vereint damit den Vorteil der Plattformunabhängigkeit des Interpreters mit dem Geschwindigkeitsvorteil des Compilers. Die Vorteile können dabei nicht genauso stark ausgespielt werden, wie bei den ursprünglichen Implementierungsformen, aber es wird ein sehr guter Mittelweg geschaffen, um sich die Leistung moderner Rechner zunutze zu machen und direkt auf dem Zielsystem zu compilieren, um die Geschwindigkeit des ausgeführten Programmteils maßgeblich zu erhöhen, als auch die Auslieferung von direkt übersetzbaren Bytecode, der die Software plattformunabhängig macht.
% TODO: Profildaten --> Was wird compiliert und warum --> Heuristik

\section{Programmausführung in der virtuellen Maschine}
Durch die Dynamik einer Programmiersprache, zur Schaffung einer Plattformunabhängigkeit oder aus Sicherheitsgründen werden Programme heutzutage oftmals nicht mehr direkt vom Betriebssystem ausgeführt, sondern laufen in einer virtuellen Maschine. Dies verzögert jedoch die Ausführungszeit der Interpretation der Befehle. \\
Durch die Anwendung von \ac{JIT} wird hier versucht Performance zu gewinnen und somit diesen Nachteil auszugleichen.

